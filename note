익명함수(Anonymous Function) -> 변수 선언에 그대로 사용할 수 있다.
val add:(Int, Int) -> Int = fun(x,y) = x+y
val result = add(4,2)
	--> 익명함수에서 선언 자료형을 람다식 형태로 써주면 변수 add는 람다식 함수처럼 add()와 같이 사용할 수 있는 것이다.
	--> 왜 람다식으로 쓰지 않고 익명함수를 쓰는 것일까? 람다식에서는 return이나 break, continue처럼 제어문을 사용하기 어렵기 때문이다.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
인라인함수(Inline function) -> 함수가 호출되는 곳에 함수 본문의 내용을 모두 복사해 넣어 함수의 분기 없이 처리되기 때문에 코드의 성능을 높일 수 있다.
	--> 인라인 함수는 람다식 매개변수를 가지고 있는 함수에서 동작한다.
	--> 보통함수는 호출되었을 때 다른 코드로 분기해야 하기 때문에 내부적으로 기존 내용을 저장했다가 다시 돌아올 때 복구하는 작업에 프로세스(CPU)와 메모리를 꽤 사용해야 하는 비용이 든다.
	
fun main(){
	// 인라인 함수 shortFunc()의 내용이 복사되어 shortFunc으로 들어감
	shortFunc(3) {println("First Call : $it")}
	shortFunc(4) {println("Second Call : $it")}
}
inline func shortFunc(a:Int, out:(Int)->Unit){
	println("Before calling out()")
	out(a)
	println("After calling out()")
}

	--> 인라인 함수의 매개변수로 사용한 람다식의 코드가 너무 길거나 인라인 함수의 본문 자체가 너무 길면 컴파일러에서 성능 경고를 할 수도 있다. 또 인라인 함수가 너무 많이 호출되면 오히려 코드 양만 늘어나서 좋지 않을 수도 있다.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<함수의 범위>
[최상위 함수와 지역 함수]
코틀린에서는 파일을 만들고 곧바로 main()함수나 사용자 함수를 만들 수 있다. 이것을 최상위 함수(Top-level Function)라고 한다. 함수 안에 또 다른 함수가 선언되어 있는 경우에는 지역 함수(Local Function)라고 한다.

[최상위 및 지역 함수의 사용 범위]
 지역 함수는 최상위 함수와 다르게 선언하는 순서에 영향을 받는다.
// a()함수에 b()함수의 내용을 선언
fun a() = b() // 최상위 함수이므로 b()함수 선언 위치에 상관없이 사용 가능
fun b() = println("b") // b() 함수의 선언

fun c(){
	// fun d() = e() // 오류!! d()는 지역함수이며 e()의 이름을 모름
	fun e() = println("e")
}

fun main(){
	a() // 최상위 함수는 어디서든 호출될 수 있음
	// e() // 오류!! c()함수에 정의된 e()는 c의 블록을 벗어난 곳에서 사용할 수 없음
}

	--> 전역변수는 최상위에 있는 변수로 프로그램이 실행되는 동안 삭제되지 않고 메모리에 유지된다. 프로그램이 실행되는 동안 값이 유지된다는 점은 편리하지만 코드가 길어지면 전역 변수에 동시 접근하는 코드는 프로그램의 잘못된 동작을 유발할 수 있다.
